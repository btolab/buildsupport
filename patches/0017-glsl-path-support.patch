From 37a5441584f3ec350f5a35d56f201bc93c502090 Mon Sep 17 00:00:00 2001
From: Jeffrey Clark <dude@zaplabs.com>
Date: Sun, 3 Apr 2016 19:21:12 +0000
Subject: [PATCH 17/17] glsl path support

---
 glsl/CRT_COMPLEX-halation.vsh           | 159 +++++++++++++++++++
 glsl/CRT_COMPLEX-halation_rgb32_dir.fsh | 269 ++++++++++++++++++++++++++++++++
 glsl/CRT_SIMPLE-halation.vsh            |  82 ++++++++++
 glsl/CRT_SIMPLE-halation_rgb32_dir.fsh  | 246 +++++++++++++++++++++++++++++
 glsl/CRT_SIMPLE-lottes.vsh              |  49 ++++++
 glsl/CRT_SIMPLE-lottes_rgb32_dir.fsh    | 223 ++++++++++++++++++++++++++
 src/osd/modules/lib/osdobj_common.cpp   |   1 +
 src/osd/modules/lib/osdobj_common.h     |   2 +
 src/osd/sdl/video.cpp                   |  16 +-
 src/osd/windows/video.cpp               |  16 +-
 10 files changed, 1055 insertions(+), 8 deletions(-)
 create mode 100644 glsl/CRT_COMPLEX-halation.vsh
 create mode 100644 glsl/CRT_COMPLEX-halation_rgb32_dir.fsh
 create mode 100644 glsl/CRT_SIMPLE-halation.vsh
 create mode 100644 glsl/CRT_SIMPLE-halation_rgb32_dir.fsh
 create mode 100644 glsl/CRT_SIMPLE-lottes.vsh
 create mode 100644 glsl/CRT_SIMPLE-lottes_rgb32_dir.fsh

diff --git a/glsl/CRT_COMPLEX-halation.vsh b/glsl/CRT_COMPLEX-halation.vsh
new file mode 100644
index 0000000..cbbd82b
--- /dev/null
+++ b/glsl/CRT_COMPLEX-halation.vsh
@@ -0,0 +1,159 @@
+// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER
+//
+//  modified a little by Luke-Nukem (admin@garagearcades.co.nz)
+//  http://www.garagearcades.co.nz
+/** Shader **/
+/// FOR CRT GEOM ///
+varying vec2 overscan;
+varying vec2 aspect;
+
+varying float d;
+varying float R;
+
+varying float cornersize;
+varying float cornersmooth;
+
+varying vec3 stretch;
+varying vec2 sinangle;
+varying vec2 cosangle;
+
+varying vec2 texCoord;
+
+varying float hardScan;
+varying float maskDark;
+varying float maskLight;
+varying float hardPix;
+varying float saturation;
+varying float tint;
+varying float blackClip;
+varying float brightMult;
+
+varying float hardBloomScan;
+varying float bloomAmount;
+
+varying float aperature_type;
+varying float bloom_on;
+
+#define FIX(c) max(abs(c), 1e-5);
+
+float intersect(vec2 xy)
+{
+  float A = dot(xy,xy)+d*d;
+  float B = 2.0*(R*(dot(xy,sinangle)-d*cosangle.x*cosangle.y)-d*d);
+  float C = d*d + 2.0*R*d*cosangle.x*cosangle.y;
+  return (-B-sqrt(B*B-4.0*A*C))/(2.0*A);
+}
+
+vec2 bkwtrans(vec2 xy)
+{
+  float c = intersect(xy);
+  vec2 point = vec2(c)*xy;
+  point -= vec2(-R)*sinangle;
+  point /= vec2(R);
+  vec2 tang = sinangle/cosangle;
+  vec2 poc = point/cosangle;
+  float A = dot(tang,tang)+1.0;
+  float B = -2.0*dot(poc,tang);
+  float C = dot(poc,poc)-1.0;
+  float a = (-B+sqrt(B*B-4.0*A*C))/(2.0*A);
+  vec2 uv = (point-a*sinangle)/cosangle;
+  float r = R*acos(a);
+  return uv*r/sin(r/R);
+}
+
+vec2 fwtrans(vec2 uv)
+{
+  float r = FIX(sqrt(dot(uv,uv)));
+  uv *= sin(r/R)/r;
+  float x = 1.0-cos(r/R);
+  float D = d/R + x*cosangle.x*cosangle.y+dot(uv,sinangle);
+  return d*(uv*cosangle-x*sinangle)/D;
+}
+
+vec3 maxscale()
+{
+  vec2 c = bkwtrans(-R * sinangle / (1.0 + R/d*cosangle.x*cosangle.y));
+  vec2 a = vec2(0.5,0.5)*aspect;
+  vec2 lo = vec2(fwtrans(vec2(-a.x,c.y)).x,
+		 fwtrans(vec2(c.x,-a.y)).y)/aspect;
+  vec2 hi = vec2(fwtrans(vec2(+a.x,c.y)).x,
+		 fwtrans(vec2(c.x,+a.y)).y)/aspect;
+  return vec3((hi+lo)*aspect*0.5,max(hi.x-lo.x,hi.y-lo.y));
+}
+
+
+void main()
+{
+    // transform the texture coordinates
+    gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+    // Do the standard vertex processing.
+    gl_Position     = ftransform();
+    // Texture coords.
+    texCoord = gl_TexCoord[0].xy;
+
+    // APERATURE_TYPE
+    // 0 = VGA style shadow mask.
+    // 1.0 = Very compressed TV style shadow mask.
+    // 2.0 = Aperture-grille.
+    aperature_type = 2.0;
+    // overscan (e.g. 1.02 for 2% overscan)
+    overscan = vec2(0.98, 0.98);
+    // aspect ratio
+    aspect = vec2(1.0, 0.9);
+    // lengths are measured in units of (approximately) the width of the monitor
+    // simulated distance from viewer to monitor
+    d = 2.0;
+    // radius of curvature
+    R = 3.0;
+    // tilt angle in radians
+    // (behavior might be a bit wrong if both components are nonzero)
+    const vec2 angle = vec2(0.0,0.0);
+    // size of curved corners
+    cornersize = 0.038;
+    // border smoothness parameter
+    // decrease if borders are too aliased
+    cornersmooth = 400.0;
+
+    // FILTER VARS
+    // YUV VARS
+    saturation = 1.25;  // 1.0 is normal saturation. Increase as needed.
+    tint = 0.1;  //0.0 is 0.0 degrees of Tint. Adjust as needed.
+    // GAMMA VARS
+    //Drops the final color value by this amount if GAMMA_CONTRAST_BOOST is defined
+    blackClip = 0.08;
+    //Multiplies the color values by this amount if GAMMA_CONTRAST_BOOST is defined
+    brightMult = 1.1;
+    // Hardness of scanline.
+    //  -8.0 = soft
+    // -16.0 = medium
+    hardScan = -13.0;
+    // Hardness of pixels in scanline.
+    // -2.0 = soft
+    // -4.0 = hard
+    hardPix = -3.0;
+
+    maskDark = 0.7; //Sets how dark a "dark subpixel" is in the aperture pattern.
+    maskLight = 1.4; //Sets how dark a "bright subpixel" is in the aperture pattern
+    // Hardness of short vertical bloom.
+    //  -1.0 = wide to the point of clipping (bad)
+    //  -1.5 = wide
+    //  -4.0 = not very wide at all
+    hardBloomScan = -2.7;
+
+    // Amount of small bloom effect.
+    //  1.0/1.0 = only bloom
+    //  1.0/16.0 = what I think is a good amount of small bloom
+    //  0.0     = no bloom
+    bloomAmount = 1.0/2.0;
+
+    // BLOOM ON/OFF SWITCH
+    bloom_on = 0.0;
+
+    // Precalculate a bunch of useful values we'll need in the fragment
+    // shader.
+    sinangle = sin(angle);
+    cosangle = cos(angle);
+    stretch = maxscale();
+}
+
+
diff --git a/glsl/CRT_COMPLEX-halation_rgb32_dir.fsh b/glsl/CRT_COMPLEX-halation_rgb32_dir.fsh
new file mode 100644
index 0000000..9b56269
--- /dev/null
+++ b/glsl/CRT_COMPLEX-halation_rgb32_dir.fsh
@@ -0,0 +1,269 @@
+#define YUV
+#define GAMMA_CONTRAST_BOOST
+#pragma optimize (on)
+#pragma debug (off)
+
+// FOR CRT GEOM
+#define FIX(c) max(abs(c), 1e-5);
+#define TEX2D(c) texture2D(mpass_texture, (c)).rgb
+varying vec2 texCoord;
+varying vec2 overscan;
+varying vec2 aspect;
+
+varying float d;
+varying float R;
+
+varying float cornersize;
+varying float cornersmooth;
+
+varying vec3 stretch;
+varying vec2 sinangle;
+varying vec2 cosangle;
+
+//Normal MAME GLSL Uniforms
+uniform sampler2D mpass_texture;
+uniform vec2      color_texture_sz;         // size of color_texture
+uniform vec2      color_texture_pow2_sz;    // size of color texture rounded up to power of 2
+
+// Filter Variables
+varying float hardScan;
+varying float maskDark;
+varying float maskLight;
+varying float hardPix;
+// Bloom Variables
+varying float hardBloomScan;
+varying float bloomAmount;
+// YUV Variables
+varying float saturation;
+varying float tint;
+// GAMMA Variables
+varying float blackClip;
+varying float brightMult;
+
+varying float aperature_type;
+varying float bloom_on;
+
+const vec3 gammaBoost = vec3(1.0/1.2, 1.0/1.2, 1.0/1.2);//An extra per channel gamma adjustment applied at the end.
+
+//Here are the Tint/Saturation/GammaContrastBoost Variables.  Comment out "#define YUV" and "#define GAMMA_CONTRAST_BOOST" to disable these altogether.
+const float PI = 3.1415926535;
+float U = cos(tint*PI/180.0);
+float W = sin(tint*PI/180.0);
+vec3  YUVr=vec3( 0.701 * saturation * U + 0.16774 * saturation * W + 0.299,0.587 - 0.32931 * saturation * W - 0.587 * saturation * U, -0.497 * saturation * W - 0.114 * saturation * U + 0.114);
+vec3  YUVg=vec3(-0.3281* saturation * W - 0.299 * saturation * U + 0.299,0.413 * saturation * U + 0.03547 * saturation * W + 0.587, 0.114 + 0.29265 * saturation * W - 0.114 * saturation * U);
+vec3  YUVb=vec3( 0.299 + 1.24955 * saturation * W - 0.299 * saturation * U, -1.04634 * saturation * W - 0.587 * saturation * U + 0.587, 0.886 * saturation * U - 0.20321 * saturation * W + 0.114);
+
+//------------------------------------------------------------------------
+// Linear to sRGB.
+// Assuing using sRGB typed textures this should not be needed.
+float ToSrgb1(float c)
+{
+    return (c < 0.0031308 ? c * 12.92 : 1.055 * pow(c, 0.41666) - 0.055);
+}
+vec3 ToSrgb(vec3 c)
+{
+    return vec3(ToSrgb1(c.r), ToSrgb1(c.g), ToSrgb1(c.b));
+}
+
+
+// sRGB to Linear.
+// Assuing using sRGB typed textures this should not be needed.
+float ToLinear1(float c)
+{
+    return (c <= 0.04045) ? c / 12.92 : pow((c+0.055)/1.055,2.4);
+}
+vec3 ToLinear(vec3 c)
+{
+    return vec3(ToLinear1(c.r), ToLinear1(c.g), ToLinear1(c.b));
+}
+// Nearest emulated sample given floating point position and texel offset.
+// Also zero's off screen.
+vec3 Fetch(vec2 pos, vec2 off)
+{
+  pos = (floor(pos * color_texture_pow2_sz + off)) / color_texture_pow2_sz;
+  return ToLinear(texture2D(mpass_texture, pos.xy).rgb);
+}
+// Distance in emulated pixels to nearest texel.
+vec2 Dist(vec2 pos)
+{
+    pos = pos * color_texture_pow2_sz;
+    return -((pos - floor(pos)) - vec2(0.5));
+}
+
+// 1D Gaussian.
+float Gaus(float pos, float scale)
+{
+    return exp2(scale * pos * pos);
+}
+
+// Return scanline weight.
+float preGaus(vec2 pos, float off, float scanf)
+{
+  float dst = Dist(pos).y;
+  return Gaus(dst + off, scanf);
+}
+
+// 3-tap Gaussian filter along horz line.
+vec3 Horz3(vec2 pos,float off)
+{
+  vec3 a = Fetch(pos, vec2(-2.0, off));
+  vec3 b = Fetch(pos, vec2(-1.0, off));
+  vec3 c = Fetch(pos, vec2( 0.0, off));
+  vec3 d = Fetch(pos, vec2( 1.0, off));
+  vec3 e = Fetch(pos, vec2(-2.0, off));
+  float dst = Dist(pos).x;
+  // Convert distance to weight.
+  float wa = Gaus(dst - 2.0, hardPix);
+  float wb = Gaus(dst - 1.0, hardPix);
+  float wc = Gaus(dst + 0.0, hardPix);
+  float wd = Gaus(dst + 1.0, hardPix);
+  float we = Gaus(dst - 2.0, hardPix);
+  // Return filtered sample.
+  //return (b * wb + c * wc + d * wd);
+  return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);
+}
+
+// Allow nearest three lines to affect pixel.
+vec3 Tri(vec2 pos)
+{
+  vec3 a = Horz3(pos,-1.0);
+  vec3 b = Horz3(pos, 0.0);
+  vec3 c = Horz3(pos, 1.0);
+  float wa = preGaus(pos, -1.0, hardScan);
+  float wb = preGaus(pos,  0.0, hardScan);
+  float wc = preGaus(pos,  1.0, hardScan);
+  return a*wa+b*wb+c*wc;
+}
+
+// Small bloom.
+vec3 Bloom(vec2 pos)
+{
+  vec3 a = Horz3(pos,-2.0);
+  vec3 b = Horz3(pos,-1.0);
+  vec3 c = Horz3(pos, 0.0);
+  vec3 d = Horz3(pos, 1.0);
+  vec3 e = Horz3(pos, 2.0);
+  float wa = preGaus(pos, -2.0, hardBloomScan);
+  float wb = preGaus(pos, -1.0, hardBloomScan);
+  float wc = preGaus(pos,  0.0, hardBloomScan);
+  float wd = preGaus(pos,  1.0, hardBloomScan);
+  float we = preGaus(pos,  2.0, hardBloomScan);
+  return a*wa+b*wb+c*wc+d*wd+e*we;}
+
+vec3 Mask(vec2 pos)
+{
+    // Very compressed TV style shadow mask.
+    if (aperature_type == 1.0)
+    {
+        float line = maskLight;
+        float odd = 0.0;
+        if (fract(pos.x / 6.0) < 0.5)
+            odd = 1.0;
+        if (fract((pos.y+odd) / 2.0) < 0.5)
+            line = maskDark;
+        pos.x = fract(pos.x / 3.0);
+        vec3 mask = vec3(maskDark, maskDark, maskDark);
+        if (pos.x < 0.333)
+            mask.r = maskLight;
+        else if (pos.x<0.666)
+            mask.g = maskLight;
+        else
+            mask.b = maskLight;
+        mask *= line;
+        return mask;
+    }
+    // Aperture-grille.
+    else if (aperature_type == 2.0)
+    {
+        pos.x = fract(pos.x / 3.0);
+        vec3 mask = vec3(maskDark, maskDark, maskDark);
+        if (pos.x < 0.333)
+            mask.r = maskLight;
+        else if (pos.x < 0.666)
+            mask.g = maskLight;
+        else
+            mask.b = maskLight;
+        return mask;
+    }
+    // VGA style shadow mask.
+    else
+    {
+        pos.xy = floor(pos.xy * vec2(1.0, 0.5));
+        pos.x += pos.y * 3.0;
+        vec3 mask = vec3(maskDark, maskDark, maskDark);
+        pos.x = fract(pos.x / 6.0);
+        if (pos.x<0.333)
+            mask.r = maskLight;
+        else if (pos.x < 0.666)
+            mask.g = maskLight;
+        else
+            mask.b = maskLight;
+        return mask;
+    }
+}
+
+/// CRT GEOMETRY SECTION ///////////////////////////////////////////////
+float intersect(vec2 xy)
+{
+  float A = dot(xy,xy)+d*d;
+  float B = 2.0*(R*(dot(xy,sinangle)-d*cosangle.x*cosangle.y)-d*d);
+  float C = d*d + 2.0*R*d*cosangle.x*cosangle.y;
+  return (-B-sqrt(B*B-4.0*A*C))/(2.0*A);
+}
+
+vec2 bkwtrans(vec2 xy)
+{
+  float c = intersect(xy);
+  vec2 point = vec2(c)*xy;
+  point -= vec2(-R)*sinangle;
+  point /= vec2(R);
+  vec2 tang = sinangle/cosangle;
+  vec2 poc = point/cosangle;
+  float A = dot(tang,tang)+1.0;
+  float B = -2.0*dot(poc,tang);
+  float C = dot(poc,poc)-1.0;
+  float a = (-B+sqrt(B*B-4.0*A*C))/(2.0*A);
+  vec2 uv = (point-a*sinangle)/cosangle;
+  float r = FIX(R*acos(a));
+  return uv*r/sin(r/R);
+}
+
+vec2 transform(vec2 coord)
+{
+  coord *= color_texture_pow2_sz / color_texture_sz;
+  coord = (coord-vec2(0.5))*aspect*stretch.z+stretch.xy;
+  return (bkwtrans(coord)/overscan/aspect+vec2(0.5)) * color_texture_sz / color_texture_pow2_sz;
+}
+
+float corner(vec2 coord)
+{
+  coord *= color_texture_pow2_sz / color_texture_sz;
+  coord = (coord - vec2(0.5)) * overscan + vec2(0.5);
+  coord = min(coord, vec2(1.0)-coord) * aspect;
+  vec2 cdist = vec2(cornersize);
+  coord = (cdist - min(coord,cdist));
+  float dist = sqrt(dot(coord,coord));
+  return clamp((cdist.x-dist)*cornersmooth,0.0, 1.0);
+}
+/// CRT GEOMETRY ENDS ///////////////////////////////////////////////
+
+// Entry.
+void main(void)
+{
+    vec2 pos = transform(texCoord); // Curvature
+    float cval = corner(pos);
+    gl_FragColor.rgb = Tri(pos) * Mask(gl_FragCoord.xy) * vec3(cval);
+    if (bloom_on == 1.0){
+        gl_FragColor.rgb += Bloom(pos) * bloomAmount;
+    }
+
+    gl_FragColor.a = 1.0;
+    gl_FragColor.rgb = ToSrgb(gl_FragColor.rgb);
+#ifdef YUV
+    gl_FragColor.rgb = vec3(dot(YUVr,gl_FragColor.rgb), dot(YUVg,gl_FragColor.rgb), dot(YUVb,gl_FragColor.rgb));
+    gl_FragColor.rgb = clamp(ToSrgb(gl_FragColor.rgb), 0.0, 1.0);
+#endif
+#ifdef GAMMA_CONTRAST_BOOST
+  gl_FragColor.rgb=brightMult*pow(gl_FragColor.rgb,gammaBoost )-vec3(blackClip);
+#endif
+}
\ No newline at end of file
diff --git a/glsl/CRT_SIMPLE-halation.vsh b/glsl/CRT_SIMPLE-halation.vsh
new file mode 100644
index 0000000..e1c3f40
--- /dev/null
+++ b/glsl/CRT_SIMPLE-halation.vsh
@@ -0,0 +1,82 @@
+/** Shader **/
+
+/// FOR CRT GEOM ///
+varying float cornersize;
+varying float cornersmooth;
+varying float distortion;
+varying vec2 texCoord;
+
+varying float hardScan;
+varying float maskDark;
+varying float maskLight;
+varying float hardPix;
+varying float saturation;
+varying float tint;
+varying float blackClip;
+varying float brightMult;
+
+varying float hardBloomScan;
+varying float bloomAmount;
+
+varying float aperature_type;
+varying float bloom_on;
+
+void main()
+{
+    // transform the texture coordinates
+    gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+    // Do the standard vertex processing.
+    gl_Position     = ftransform();
+    // Texture coords.
+    texCoord = gl_TexCoord[0].xy;
+
+    // APERATURE_TYPE
+    // 0 = VGA style shadow mask.
+    // 1.0 = Very compressed TV style shadow mask.
+    // 2.0 = Aperture-grille.
+    aperature_type = 2.0;
+    // size of curved corners
+    cornersize = 0.038;
+    // border smoothness parameter
+    // decrease if borders are too aliased
+    cornersmooth = 400.0;
+    //
+    distortion = 0.1;
+
+    // FILTER VARS
+    // YUV VARS
+    saturation = 1.05;  // 1.0 is normal saturation. Increase as needed.
+    tint = 0.1;  //0.0 is 0.0 degrees of Tint. Adjust as needed.
+    // GAMMA VARS
+    //Drops the final color value by this amount if GAMMA_CONTRAST_BOOST is defined
+    blackClip = 0.08;
+    //Multiplies the color values by this amount if GAMMA_CONTRAST_BOOST is defined
+    brightMult = 1.2;
+    // Hardness of scanline.
+    //  -8.0 = soft
+    // -16.0 = medium
+    hardScan = -13.0;
+    // Hardness of pixels in scanline.
+    // -2.0 = soft
+    // -4.0 = hard
+    hardPix = -3.0;
+
+    maskDark = 0.7; //Sets how dark a "dark subpixel" is in the aperture pattern.
+    maskLight = 1.4; //Sets how dark a "bright subpixel" is in the aperture pattern
+    // Hardness of short vertical bloom.
+    //  -1.0 = wide to the point of clipping (bad)
+    //  -1.5 = wide
+    //  -4.0 = not very wide at all
+    hardBloomScan = -2.7;
+
+    // Amount of small bloom effect.
+    //  1.0/1.0 = only bloom
+    //  1.0/16.0 = what I think is a good amount of small bloom
+    //  0.0     = no bloom
+    bloomAmount = 1.0/2.0;
+
+    // BLOOM ON/OFF SWITCH
+    bloom_on = 0.0;
+}
+
+
diff --git a/glsl/CRT_SIMPLE-halation_rgb32_dir.fsh b/glsl/CRT_SIMPLE-halation_rgb32_dir.fsh
new file mode 100644
index 0000000..f640cef
--- /dev/null
+++ b/glsl/CRT_SIMPLE-halation_rgb32_dir.fsh
@@ -0,0 +1,246 @@
+//
+// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER
+//
+//   by Timothy Lottes
+//
+// This is more along the style of a really good CGA arcade monitor.
+// With RGB inputs instead of NTSC.
+// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.
+//
+// Converted to MAME and AttractMode FE by Luke-Nukem (admin@garagearcades.co.nz)
+//  http://www.garagearcades.co.nz
+//#define YUV
+#define GAMMA_CONTRAST_BOOST
+#pragma optimize (on)
+#pragma debug (off)
+
+// FOR CRT GEOM
+#define FIX(c) max(abs(c), 1e-5);
+#define TEX2D(c) texture2D(mpass_texture, (c)).rgb
+varying vec2 texCoord;
+varying float distortion;
+varying float cornersize;
+varying float cornersmooth;
+
+//Normal MAME GLSL Uniforms
+uniform sampler2D mpass_texture;
+uniform vec2      color_texture_sz;         // size of color_texture
+uniform vec2      color_texture_pow2_sz;    // size of color texture rounded up to power of 2
+
+// Filter Variables
+varying float hardScan;
+varying float maskDark;
+varying float maskLight;
+varying float hardPix;
+// Bloom Variables
+varying float hardBloomScan;
+varying float bloomAmount;
+// YUV Variables
+varying float saturation;
+varying float tint;
+// GAMMA Variables
+varying float blackClip;
+varying float brightMult;
+
+varying float aperature_type;
+varying float bloom_on;
+
+const vec3 gammaBoost = vec3(1.0/1.2, 1.0/1.2, 1.0/1.2);//An extra per channel gamma adjustment applied at the end.
+
+//Here are the Tint/Saturation/GammaContrastBoost Variables.  Comment out "#define YUV" and "#define GAMMA_CONTRAST_BOOST" to disable these altogether.
+const float PI = 3.1415926535;
+float U = cos(tint*PI/180.0);
+float W = sin(tint*PI/180.0);
+vec3  YUVr=vec3( 0.701 * saturation * U + 0.16774 * saturation * W + 0.299,0.587 - 0.32931 * saturation * W - 0.587 * saturation * U, -0.497 * saturation * W - 0.114 * saturation * U + 0.114);
+vec3  YUVg=vec3(-0.3281* saturation * W - 0.299 * saturation * U + 0.299,0.413 * saturation * U + 0.03547 * saturation * W + 0.587, 0.114 + 0.29265 * saturation * W - 0.114 * saturation * U);
+vec3  YUVb=vec3( 0.299 + 1.24955 * saturation * W - 0.299 * saturation * U, -1.04634 * saturation * W - 0.587 * saturation * U + 0.587, 0.886 * saturation * U - 0.20321 * saturation * W + 0.114);
+
+//------------------------------------------------------------------------
+// Linear to sRGB.
+// Assuing using sRGB typed textures this should not be needed.
+float ToSrgb1(float c)
+{
+    return (c < 0.0031308 ? c * 12.92 : 1.055 * pow(c, 0.41666) - 0.055);
+}
+vec3 ToSrgb(vec3 c)
+{
+    return vec3(ToSrgb1(c.r), ToSrgb1(c.g), ToSrgb1(c.b));
+}
+
+
+// sRGB to Linear.
+// Assuing using sRGB typed textures this should not be needed.
+float ToLinear1(float c)
+{
+    return (c <= 0.04045) ? c / 12.92 : pow((c+0.055)/1.055,2.4);
+}
+vec3 ToLinear(vec3 c)
+{
+    return vec3(ToLinear1(c.r), ToLinear1(c.g), ToLinear1(c.b));
+}
+// Nearest emulated sample given floating point position and texel offset.
+// Also zero's off screen.
+vec3 Fetch(vec2 pos, vec2 off)
+{
+  pos = (floor(pos * color_texture_pow2_sz + off)) / color_texture_pow2_sz;
+  return ToLinear(texture2D(mpass_texture, pos.xy).rgb);
+}
+// Distance in emulated pixels to nearest texel.
+vec2 Dist(vec2 pos)
+{
+    pos = pos * color_texture_pow2_sz;
+    return -((pos - floor(pos)) - vec2(0.5));
+}
+
+// 1D Gaussian.
+float Gaus(float pos, float scale)
+{
+    return exp2(scale * pos * pos);
+}
+
+// Return scanline weight.
+float preGaus(vec2 pos, float off, float scanf)
+{
+  float dst = Dist(pos).y;
+  return Gaus(dst + off, scanf);
+}
+
+// 3-tap Gaussian filter along horz line.
+vec3 Horz3(vec2 pos,float off)
+{
+  vec3 a = Fetch(pos, vec2(-2.0, off));
+  vec3 b = Fetch(pos, vec2(-1.0, off));
+  vec3 c = Fetch(pos, vec2( 0.0, off));
+  vec3 d = Fetch(pos, vec2( 1.0, off));
+  vec3 e = Fetch(pos, vec2(-2.0, off));
+  float dst = Dist(pos).x;
+  // Convert distance to weight.
+  float wa = Gaus(dst - 2.0, hardPix);
+  float wb = Gaus(dst - 1.0, hardPix);
+  float wc = Gaus(dst + 0.0, hardPix);
+  float wd = Gaus(dst + 1.0, hardPix);
+  float we = Gaus(dst - 2.0, hardPix);
+  // Return filtered sample.
+  //return (b * wb + c * wc + d * wd);
+  return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);
+}
+
+// Allow nearest three lines to affect pixel.
+vec3 Tri(vec2 pos)
+{
+  vec3 a = Horz3(pos,-1.0);
+  vec3 b = Horz3(pos, 0.0);
+  vec3 c = Horz3(pos, 1.0);
+  float wa = preGaus(pos, -1.0, hardScan);
+  float wb = preGaus(pos,  0.0, hardScan);
+  float wc = preGaus(pos,  1.0, hardScan);
+  return a*wa+b*wb+c*wc;
+}
+
+// Small bloom.
+vec3 Bloom(vec2 pos)
+{
+  vec3 a = Horz3(pos,-2.0);
+  vec3 b = Horz3(pos,-1.0);
+  vec3 c = Horz3(pos, 0.0);
+  vec3 d = Horz3(pos, 1.0);
+  vec3 e = Horz3(pos, 2.0);
+  float wa = preGaus(pos, -2.0, hardBloomScan);
+  float wb = preGaus(pos, -1.0, hardBloomScan);
+  float wc = preGaus(pos,  0.0, hardBloomScan);
+  float wd = preGaus(pos,  1.0, hardBloomScan);
+  float we = preGaus(pos,  2.0, hardBloomScan);
+  return a*wa+b*wb+c*wc+d*wd+e*we;}
+
+vec3 Mask(vec2 pos)
+{
+    // Very compressed TV style shadow mask.
+    if (aperature_type == 1.0)
+    {
+        float line = maskLight;
+        float odd = 0.0;
+        if (fract(pos.x / 6.0) < 0.5)
+            odd = 1.0;
+        if (fract((pos.y+odd) / 2.0) < 0.5)
+            line = maskDark;
+        pos.x = fract(pos.x / 3.0);
+        vec3 mask = vec3(maskDark, maskDark, maskDark);
+        if (pos.x < 0.333)
+            mask.r = maskLight;
+        else if (pos.x<0.666)
+            mask.g = maskLight;
+        else
+            mask.b = maskLight;
+        mask *= line;
+        return mask;
+    }
+    // Aperture-grille.
+    else if (aperature_type == 2.0)
+    {
+        pos.x = fract(pos.x / 3.0);
+        vec3 mask = vec3(maskDark, maskDark, maskDark);
+        if (pos.x < 0.333)
+            mask.r = maskLight;
+        else if (pos.x < 0.666)
+            mask.g = maskLight;
+        else
+            mask.b = maskLight;
+        return mask;
+    }
+    // VGA style shadow mask.
+    else
+    {
+        pos.xy = floor(pos.xy * vec2(1.0, 0.5));
+        pos.x += pos.y * 3.0;
+        vec3 mask = vec3(maskDark, maskDark, maskDark);
+        pos.x = fract(pos.x / 6.0);
+        if (pos.x<0.333)
+            mask.r = maskLight;
+        else if (pos.x < 0.666)
+            mask.g = maskLight;
+        else
+            mask.b = maskLight;
+        return mask;
+    }
+}
+
+/// CRT GEOMETRY SECTION ///////////////////////////////////////////////
+vec2 radialDistortion(vec2 coord) {
+    coord *= color_texture_pow2_sz / color_texture_sz;
+    vec2 cc = coord - vec2(0.5);
+    float dist = dot(cc, cc) * distortion;
+    return (coord + cc * (1.0 + dist) * dist) * color_texture_sz / color_texture_pow2_sz;
+}
+
+float corner(vec2 coord)
+{
+  coord *= color_texture_pow2_sz / color_texture_sz;
+  coord = (coord - vec2(0.5)) + vec2(0.5);
+  coord = min(coord, vec2(1.0)-coord);
+  vec2 cdist = vec2(cornersize);
+  coord = (cdist - min(coord,cdist));
+  float dist = sqrt(dot(coord,coord));
+  return clamp((cdist.x-dist)*cornersmooth,0.0, 1.0);
+}
+/// CRT GEOMETRY ENDS ///////////////////////////////////////////////
+
+// Entry.
+void main(void)
+{
+    vec2 pos = radialDistortion(texCoord); // Curvature
+    //gl_FragColor.rgb *= vec3(corner(pos));
+    gl_FragColor.rgb = Tri(pos) * Mask(gl_FragCoord.xy) * vec3(corner(pos));
+    if (bloom_on == 1.0){
+        gl_FragColor.rgb += Bloom(pos) * bloomAmount;
+    }
+
+    gl_FragColor.a = 1.0;
+    gl_FragColor.rgb = ToSrgb(gl_FragColor.rgb);
+#ifdef YUV
+    gl_FragColor.rgb = vec3(dot(YUVr,gl_FragColor.rgb), dot(YUVg,gl_FragColor.rgb), dot(YUVb,gl_FragColor.rgb));
+    gl_FragColor.rgb = clamp(ToSrgb(gl_FragColor.rgb), 0.0, 1.0);
+#endif
+#ifdef GAMMA_CONTRAST_BOOST
+  gl_FragColor.rgb=brightMult*pow(gl_FragColor.rgb,gammaBoost )-vec3(blackClip);
+#endif
+}
\ No newline at end of file
diff --git a/glsl/CRT_SIMPLE-lottes.vsh b/glsl/CRT_SIMPLE-lottes.vsh
new file mode 100644
index 0000000..e3461b8
--- /dev/null
+++ b/glsl/CRT_SIMPLE-lottes.vsh
@@ -0,0 +1,49 @@
+/** Shader **/
+
+/// FOR CRT GEOM ///
+varying float cornersize;
+varying float cornersmooth;
+varying float distortion;
+varying vec2 texCoord;
+
+varying float hardScan;
+varying float maskDark;
+varying float maskLight;
+varying float hardPix;
+varying float saturation;
+varying float tint;
+varying float blackClip;
+varying float brightMult;
+varying float aperature_type;
+
+void main()
+{
+    texCoord = gl_MultiTexCoord0.xy;
+    gl_TexCoord[0]  =  gl_MultiTexCoord0;
+    gl_Position     = ftransform();
+    /// CRT GEOMETRY ///
+    // APERATURE_TYPE
+    // 0 = VGA style shadow mask.
+    // 1.0 = Very compressed TV style shadow mask.
+    // 2.0 = Aperture-grille.
+    aperature_type = 0.0;
+    // aspect ratio
+    distortion = 0.1;
+    // size of curved corners
+    cornersize = 0.038;
+    // border smoothness parameter
+    // decrease if borders are too aliased
+    cornersmooth = 400.0;
+    /// CRT GEOMETRY END ///
+    // FILTER VARS
+    hardScan=-12.0; //-8,-12,-16, etc to make scalines more prominent.
+    maskDark=0.4; //Sets how dark a "dark subpixel" is in the aperture pattern.
+    maskLight=1.0; //Sets how dark a "bright subpixel" is in the aperture pattern.
+    hardPix=-2.3; //-1,-2,-4, etc to make the upscaling sharper.
+    // YUV VARS
+    saturation = 1.25;  // 1.0 is normal saturation. Increase as needed.
+    tint = 0.1;  //0.0 is 0.0 degrees of Tint. Adjust as needed.
+    // GAMMA VARS
+    blackClip = 0.08;  //Drops the final color value by this amount if GAMMA_CONTRAST_BOOST is defined
+    brightMult = 1.25; //Multiplies the color values by this amount if GAMMA_CONTRAST_BOOST is defined
+}
diff --git a/glsl/CRT_SIMPLE-lottes_rgb32_dir.fsh b/glsl/CRT_SIMPLE-lottes_rgb32_dir.fsh
new file mode 100644
index 0000000..d80ac3e
--- /dev/null
+++ b/glsl/CRT_SIMPLE-lottes_rgb32_dir.fsh
@@ -0,0 +1,223 @@
+//
+// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER
+//
+//   by Timothy Lottes
+//
+// This is more along the style of a really good CGA arcade monitor.
+// With RGB inputs instead of NTSC.
+// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.
+//
+// Converted to MAME and AttractMode FE by Luke-Nukem (admin@garagearcades.co.nz)
+//  http://www.garagearcades.co.nz
+//
+//Comment these out to disable the corresponding effect.
+#define CURVATURE // CRT Screen Shape
+#define YUV // Saturation and Tint
+#define GAMMA_CONTRAST_BOOST //Expands contrast and makes image brighter but causes clipping.
+//#define ORIGINAL_SCANLINES //Enable to use the original scanlines.
+#define ORIGINAL_HARDPIX //Enable to use the original hardPix calculation.  But systems rendered in lower res textures will be much blurrier than systems in higher resolution textures (compare NES and TG16...)
+
+#pragma optimize (on)
+#pragma debug (off)
+
+// FOR CRT GEOM
+#define FIX(c) max(abs(c), 1e-5);
+#define TEX2D(c) texture2D(mpass_texture, (c)).rgb
+varying vec2 texCoord;
+varying float distortion;
+varying float cornersize;
+varying float cornersmooth;
+
+//Normal MAME GLSL Uniforms
+uniform sampler2D mpass_texture;
+uniform vec2      color_texture_sz;         // size of color_texture
+uniform vec2      color_texture_pow2_sz;    // size of color texture rounded up to power of 2
+
+// Filter Variables
+varying float hardScan;
+varying float maskDark;
+varying float maskLight;
+varying float hardPix;
+// YUV Variables
+varying float saturation;
+varying float tint;
+// GAMMA Variables
+varying float blackClip;
+varying float brightMult;
+const vec3 gammaBoost = vec3(1.0/1.2, 1.0/1.2, 1.0/1.2);//An extra per channel gamma adjustment applied at the end.
+
+//Here are the Tint/Saturation/GammaContrastBoost Variables.  Comment out "#define YUV" and "#define GAMMA_CONTRAST_BOOST" to disable these altogether.
+const float PI = 3.1415926535;
+float U = cos(tint*PI/180.0);
+float W = sin(tint*PI/180.0);
+vec3  YUVr=vec3( 0.701 * saturation * U + 0.16774 * saturation * W + 0.299,0.587 - 0.32931 * saturation * W - 0.587 * saturation * U, -0.497 * saturation * W - 0.114 * saturation * U + 0.114);
+vec3  YUVg=vec3(-0.3281* saturation * W - 0.299 * saturation * U + 0.299,0.413 * saturation * U + 0.03547 * saturation * W + 0.587, 0.114 + 0.29265 * saturation * W - 0.114 * saturation * U);
+vec3  YUVb=vec3( 0.299 + 1.24955 * saturation * W - 0.299 * saturation * U, -1.04634 * saturation * W - 0.587 * saturation * U + 0.587, 0.886 * saturation * U - 0.20321 * saturation * W + 0.114);
+
+// sRGB to Linear.
+// Assuing using sRGB typed textures this should not be needed.
+float ToLinear1(float c)
+{
+    return(c <= 0.04045) ? c / 12.92 : pow((c+0.055) / 1.055,2.4);
+}
+vec3 ToLinear(vec3 c)
+{
+    return vec3( ToLinear1(c.r), ToLinear1(c.g), ToLinear1(c.b) );
+}
+
+// Linear to sRGB.
+// Assuing using sRGB typed textures this should not be needed.
+float ToSrgb1(float c)
+{
+    return( c < 0.0031308 ? c * 12.92 : 1.055 * pow(c,0.41666) - 0.055);
+}
+vec3 ToSrgb(vec3 c)
+{
+    return vec3(ToSrgb1(c.r), ToSrgb1(c.g), ToSrgb1(c.b));
+}
+
+// Nearest emulated sample given floating point position and texel offset.
+// Also zero's off screen.
+vec3 Fetch(vec2 pos, vec2 off)
+{
+  pos = (floor(pos * color_texture_pow2_sz + off) + 0.5) / color_texture_pow2_sz;
+  //if(max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5)return vec3(0.0,0.0,0.0);
+  return ToLinear(texture2D(mpass_texture, pos.xy).rgb);
+}
+
+// Distance in emulated pixels to nearest texel.
+vec2 Dist(vec2 pos)
+{
+    pos = pos * color_texture_pow2_sz;
+    return -((pos - floor(pos)) - vec2(0.5));
+}
+
+// 1D Gaussian.
+float Gaus(float pos,float scale)
+{
+    return exp2(scale * pos * pos);
+}
+
+// 3-tap Gaussian filter along horz line.
+vec3 Horz3(vec2 pos,float off)
+{
+  vec3 b = Fetch(pos, vec2(-1.0, off));
+  vec3 c = Fetch(pos, vec2( 0.0, off));
+  vec3 d = Fetch(pos, vec2( 1.0, off));
+  float dst = Dist(pos).x;
+  // Convert distance to weight.
+#ifdef ORIGINAL_HARDPIX
+  float scale = hardPix;
+#else
+  float scale = hardPix * max(0.0, 2.0 - color_texture_sz.x / 512.0);//Modified to keep sharpness somewhat comparable across drivers.
+#endif
+  float wb = Gaus(dst - 1.0, scale);
+  float wc = Gaus(dst + 0.0, scale);
+  float wd = Gaus(dst + 1.0, scale);
+  // Return filtered sample.
+  return (b * wb + c * wc + d * wd) / (wb + wc + wd);}
+
+// 5-tap Gaussian filter along horz line.
+vec3 Horz5(vec2 pos,float off)
+{
+  vec3 a = Fetch(pos, vec2(-2.0, off));
+  vec3 b = Fetch(pos, vec2(-1.0, off));
+  vec3 c = Fetch(pos, vec2( 0.0, off));
+  vec3 d = Fetch(pos, vec2( 1.0, off));
+  vec3 e = Fetch(pos, vec2( 2.0, off));
+  float dst = Dist(pos).x;
+  // Convert distance to weight.
+#ifdef ORIGINAL_HARDPIX
+  float scale = hardPix;
+#else
+  float scale = hardPix * max(0.0, 2.0 - color_texture_sz.x / 512.0);//Modified to keep sharpness somewhat comparable across drivers.
+#endif
+  float wa = Gaus(dst - 2.0, scale);
+  float wb = Gaus(dst - 1.0, scale);
+  float wc = Gaus(dst + 0.0, scale);
+  float wd = Gaus(dst + 1.0, scale);
+  float we = Gaus(dst + 2.0, scale);
+  // Return filtered sample.
+  return (a * wa + b * wb + c * wc + d * wd + e * we) / (wa + wb + wc + wd + we);
+}
+
+// Return scanline weight.
+float Scan(vec2 pos,float off)
+{
+  float dst = Dist(pos).y;
+  vec3 col = Fetch(pos,vec2(0.0));
+#ifdef ORIGINAL_SCANLINES
+  return Gaus(dst + off, hardScan);
+}
+#else
+  return Gaus( dst + off, hardScan / (dot(col, col) * 0.1667 + 1.0) );
+} //Modified to make scanline respond to pixel brightness
+#endif
+
+// Allow nearest three lines to effect pixel.
+vec3 Tri(vec2 pos)
+{
+  vec3 a = Horz3(pos, -1.0);
+  vec3 b = Horz5(pos, 0.0);
+  vec3 c = Horz3(pos, 1.0);
+  float wa = Scan(pos, -1.0);
+  float wb = Scan(pos, 0.0);
+  float wc = Scan(pos, 1.0);
+  return a * wa + b * wb + c * wc;
+}
+	
+// Shadow mask.
+vec3 Mask(vec2 pos)
+{
+  pos.x += pos.y * 3.0;
+  vec3 mask = vec3(maskDark);
+  pos.x = fract(pos.x / 6.0);
+  if (pos.x < 0.333)
+      mask.r = maskLight;
+  else if (pos.x < 0.666)
+      mask.g = maskLight;
+  else
+      mask.b = maskLight;
+  return mask;
+}
+///////////////////////////////////////////////////////////////
+/// CRT GEOM FUNCTIONS ///
+// GIVES THE CURVE
+vec2 radialDistortion(vec2 coord) {
+    coord *= color_texture_pow2_sz / color_texture_sz;
+    vec2 cc = coord - vec2(0.5);
+    float dist = dot(cc, cc) * distortion;
+    return (coord + cc * (1.0 + dist) * dist) * color_texture_sz / color_texture_pow2_sz;
+}
+
+float corner(vec2 coord)
+{
+  coord *= color_texture_pow2_sz / color_texture_sz;
+  coord = (coord - vec2(0.5)) + vec2(0.5);
+  coord = min(coord, vec2(1.0)-coord);
+  vec2 cdist = vec2(cornersize);
+  coord = (cdist - min(coord,cdist));
+  float dist = sqrt(dot(coord,coord));
+  return clamp((cdist.x-dist)*cornersmooth,0.0, 1.0);
+}
+///////////////////////////////////////////////////////////////
+void main(void)
+{
+#ifdef CURVATURE
+  vec2 pos = radialDistortion(texCoord);//CURVATURE
+  //FINAL//
+  gl_FragColor.rgb = Tri(pos) * Mask(gl_FragCoord.xy) * vec3(corner(pos));
+#else
+  vec2 pos = gl_TexCoord[0].xy;
+  gl_FragColor.rgb = Tri(pos) * Mask(gl_FragCoord.xy);
+#endif
+
+#ifdef YUV
+  gl_FragColor.rgb = vec3(dot(YUVr,gl_FragColor.rgb), dot(YUVg,gl_FragColor.rgb), dot(YUVb,gl_FragColor.rgb));
+  gl_FragColor.rgb = clamp(ToSrgb(gl_FragColor.rgb), 0.0, 1.0);
+#endif
+
+#ifdef GAMMA_CONTRAST_BOOST
+  gl_FragColor.rgb=brightMult*pow(gl_FragColor.rgb,gammaBoost )-vec3(blackClip);
+#endif
+}
diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index a1ab9ab..89e5819 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -91,6 +91,7 @@ const options_entry osd_options::s_option_entries[] =
 
 #if USE_OPENGL
 	{ nullptr,                                nullptr,          OPTION_HEADER,    "OpenGL-SPECIFIC OPTIONS" },
+	{ OSDOPTION_GLSLPATH,                     "glsl",           OPTION_STRING,    "path to glsl files" },
 	{ OSDOPTION_GL_FORCEPOW2TEXTURE,          "0",              OPTION_BOOLEAN,   "force power of two textures  (default no)" },
 	{ OSDOPTION_GL_NOTEXTURERECT,             "0",              OPTION_BOOLEAN,   "don't use OpenGL GL_ARB_texture_rectangle (default on)" },
 	{ OSDOPTION_GL_VBO,                       "1",              OPTION_BOOLEAN,   "enable OpenGL VBO,  if available (default on)" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 0230cfe..7541999 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -57,6 +57,7 @@
 #define OSDOPTION_FILTER                "filter"
 #define OSDOPTION_PRESCALE              "prescale"
 
+#define OSDOPTION_GLSLPATH              "glslpath"
 #define OSDOPTION_SHADER_MAME           "glsl_shader_mame"
 #define OSDOPTION_SHADER_SCREEN         "glsl_shader_screen"
 #define OSDOPTION_GLSL_FILTER           "gl_glsl_filter"
@@ -130,6 +131,7 @@ public:
 	int prescale() const { return int_value(OSDOPTION_PRESCALE); }
 
 	// OpenGL specific options
+	const char *gl_glsl_dir() const { return value(OSDOPTION_GLSLPATH); }
 	bool gl_force_pow2_texture() const { return bool_value(OSDOPTION_GL_FORCEPOW2TEXTURE); }
 	bool gl_no_texture_rect() const { return bool_value(OSDOPTION_GL_NOTEXTURERECT); }
 	bool gl_vbo() const { return bool_value(OSDOPTION_GL_VBO); }
diff --git a/src/osd/sdl/video.cpp b/src/osd/sdl/video.cpp
index 08938b9..af45a5e 100644
--- a/src/osd/sdl/video.cpp
+++ b/src/osd/sdl/video.cpp
@@ -410,6 +410,8 @@ void sdl_osd_interface::extract_video_config()
 		if ( video_config.glsl )
 		{
 			int i;
+			const char *glsl_dir = options().gl_glsl_dir();
+			int glsl_dir_l = strlen(glsl_dir) + strlen(PATH_SEPARATOR);
 
 			video_config.glsl_filter = options().glsl_filter();
 
@@ -420,8 +422,11 @@ void sdl_osd_interface::extract_video_config()
 				stemp = options().shader_mame(i);
 				if (stemp && strcmp(stemp, OSDOPTVAL_NONE) != 0 && strlen(stemp)>0)
 				{
-					video_config.glsl_shader_mamebm[i] = (char *) malloc(strlen(stemp)+1);
-					strcpy(video_config.glsl_shader_mamebm[i], stemp);
+					video_config.glsl_shader_mamebm[i] = (char *) osd_malloc(strlen(stemp)+glsl_dir_l+1);
+					if (glsl_dir && strcmp(glsl_dir, OSDOPTVAL_NONE) != 0 && strlen(glsl_dir) > 0)
+						sprintf(video_config.glsl_shader_mamebm[i], "%s%s%s", glsl_dir, PATH_SEPARATOR, stemp);
+					else
+						sprintf(video_config.glsl_shader_mamebm[i], "%s", stemp);
 					video_config.glsl_shader_mamebm_num++;
 				} else {
 					video_config.glsl_shader_mamebm[i] = NULL;
@@ -435,8 +440,11 @@ void sdl_osd_interface::extract_video_config()
 				stemp = options().shader_screen(i);
 				if (stemp && strcmp(stemp, OSDOPTVAL_NONE) != 0 && strlen(stemp)>0)
 				{
-					video_config.glsl_shader_scrn[i] = (char *) malloc(strlen(stemp)+1);
-					strcpy(video_config.glsl_shader_scrn[i], stemp);
+					video_config.glsl_shader_scrn[i] = (char *) osd_malloc(strlen(stemp)+glsl_dir_l+1);
+					if (glsl_dir && strcmp(glsl_dir, OSDOPTVAL_NONE) != 0 && strlen(glsl_dir) > 0)
+						sprintf(video_config.glsl_shader_scrn[i], "%s%s%s", glsl_dir, PATH_SEPARATOR, stemp);
+					else
+						sprintf(video_config.glsl_shader_scrn[i], "%s", stemp);
 					video_config.glsl_shader_scrn_num++;
 				} else {
 					video_config.glsl_shader_scrn[i] = NULL;
diff --git a/src/osd/windows/video.cpp b/src/osd/windows/video.cpp
index 5592136..f51985d 100644
--- a/src/osd/windows/video.cpp
+++ b/src/osd/windows/video.cpp
@@ -412,6 +412,8 @@ void windows_osd_interface::extract_video_config()
 		if ( video_config.glsl )
 		{
 			int i;
+			const char *glsl_dir = options().gl_glsl_dir();
+			int glsl_dir_l = strlen(glsl_dir) + strlen(PATH_SEPARATOR);
 
 			video_config.glsl_filter = options().glsl_filter();
 
@@ -422,8 +424,11 @@ void windows_osd_interface::extract_video_config()
 				stemp = options().shader_mame(i);
 				if (stemp && strcmp(stemp, OSDOPTVAL_NONE) != 0 && strlen(stemp)>0)
 				{
-					video_config.glsl_shader_mamebm[i] = (char *) malloc(strlen(stemp)+1);
-					strcpy(video_config.glsl_shader_mamebm[i], stemp);
+					video_config.glsl_shader_mamebm[i] = (char *) osd_malloc(strlen(stemp)+glsl_dir_l+1);
+					if (glsl_dir && strcmp(glsl_dir, OSDOPTVAL_NONE) != 0 && strlen(glsl_dir) > 0)
+						sprintf(video_config.glsl_shader_mamebm[i], "%s%s%s", glsl_dir, PATH_SEPARATOR, stemp);
+					else
+						sprintf(video_config.glsl_shader_mamebm[i], "%s", stemp);
 					video_config.glsl_shader_mamebm_num++;
 				} else {
 					video_config.glsl_shader_mamebm[i] = NULL;
@@ -437,8 +442,11 @@ void windows_osd_interface::extract_video_config()
 				stemp = options().shader_screen(i);
 				if (stemp && strcmp(stemp, OSDOPTVAL_NONE) != 0 && strlen(stemp)>0)
 				{
-					video_config.glsl_shader_scrn[i] = (char *) malloc(strlen(stemp)+1);
-					strcpy(video_config.glsl_shader_scrn[i], stemp);
+					video_config.glsl_shader_scrn[i] = (char *) osd_malloc(strlen(stemp)+glsl_dir_l+1);
+					if (glsl_dir && strcmp(glsl_dir, OSDOPTVAL_NONE) != 0 && strlen(glsl_dir) > 0)
+						sprintf(video_config.glsl_shader_scrn[i], "%s%s%s", glsl_dir, PATH_SEPARATOR, stemp);
+					else
+						sprintf(video_config.glsl_shader_scrn[i], "%s", stemp);
 					video_config.glsl_shader_scrn_num++;
 				} else {
 					video_config.glsl_shader_scrn[i] = NULL;
-- 
2.8.0

